

# This file was *autogenerated* from the file frobenius.sage
from sage.all_cmdline import *   # import sage library

_sage_const_5 = Integer(5); _sage_const_10 = Integer(10); _sage_const_26 = Integer(26); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0)
import sys
from sage.all import *

p = _sage_const_5 
Z5 = Zp(p, prec = _sage_const_10 , type = 'capped-abs', print_mode = 'series')
R = PowerSeriesRing(Z5,'x')
x = R.gen()
S = PowerSeriesRing(R,'z')
z = S.gen()

E = EllipticCurve([_sage_const_26 ,_sage_const_1 ])
f = x**_sage_const_3 +E.a4()*x+E.a6()
frob_x = x**p
#frob_y = y^p*(1+(f(x^p)-f(x)^p)*1/f(x)^p)^(1/2)
frob_z = z**p*(_sage_const_1 +(f(x**p)-f(x)**p)*z**(_sage_const_2 *p))**(-_sage_const_1 /_sage_const_2 )

frob_omega = p*x**(p-_sage_const_1 )*frob_z
frob_eta = p*x**(_sage_const_2 *p-_sage_const_1 )*frob_z

V = LaurentSeriesRing(S)

from sage.all import *

def reduction_coeff(pow_ser):
    pow_ser_2 = pow_ser
    for i in range(len(pow_ser_2.coefficients())):
        pow_ser += -z**pow_ser_2.exponents()[i]*pow_ser_2.coefficients()[i]+z**pow_ser_2.exponents()[i]*reduction_deg_2g(f,pow_ser_2.coefficients()[i])
    return pow_ser

def reduction_deg_2g(f,pol):
    #f=x^3+ax+b
    if pol(z=_sage_const_1 ).degree()<_sage_const_3 :
        return pol
    else: 
        n = pol(z=_sage_const_1 ).degree()
        pol += - pol(z=_sage_const_1 ).coefficients()[len(pol(z=_sage_const_1 ).coefficients())-_sage_const_1 ]*(f**(floor(n/_sage_const_3 ))-_sage_const_1 /z**(_sage_const_2 *floor(n/_sage_const_3 )))*x**(n%_sage_const_3 )
        return reduction_deg_2g(f,pol)

def differential_zn(f,i,n):
    """
    Compute the exact differential d(x^iz^n) with i=0,1,2 and n integer
    return p(x,z) where p(x,z)dx=d(x^i z^n) and p(x,z)=\sum p_i(x)z^i with degree(p_i(x))<3 
    """
    if n == _sage_const_0 :
        return i*x**(i-_sage_const_1 )*z**_sage_const_0 
    return (i*x**(i-_sage_const_1 )*z**n+reduction_deg_2g(f,-_sage_const_1 /_sage_const_2 *n*f.derivative(x)*x**i)*z**(n+_sage_const_2 ))


def matrix_coeff_differentials_pos(n):
    matrix_diff = matrix(QQ,_sage_const_3 )
    for i in range(_sage_const_3 ):
        if differential_zn(f,i,n) == _sage_const_0 :
            pol_coef = _sage_const_0 
        else:
            pol_coef = differential_zn(f,i,n).coefficients()[-_sage_const_1 ]
        for j in range(_sage_const_3 ):
            if pol_coef == _sage_const_0 :
                matrix_diff[j,i] = _sage_const_0 
            else:
                matrix_diff[j,i] = pol_coef[j]
    return matrix_diff

def matrix_coeff_differentials_neg(n):
    matrix_diff = matrix(QQ,_sage_const_3 )
    for i in range(_sage_const_3 ):
        if differential_zn(f,i,n) == _sage_const_0 :
            pol_coef = _sage_const_0 
        else:
            if i == _sage_const_0 :
                pol_coef = differential_zn(f,i,n-_sage_const_2 ).coefficients()[_sage_const_0 ]
            else:
                pol_coef = differential_zn(f,i,n).coefficients()[_sage_const_0 ]
        for j in range(_sage_const_3 ):
            if pol_coef == _sage_const_0 :
                matrix_diff[j,i] = _sage_const_0 
            else:
                matrix_diff[j,i] = pol_coef[j]
    return matrix_diff

def vector_coeff(pol):
    return vector([pol[_sage_const_0 ],pol[_sage_const_1 ],pol[_sage_const_2 ]])

def reduction_z_pos(pow_ser,exact_form=_sage_const_0 ):
    if pow_ser.degree()<_sage_const_3 :
        return (pow_ser,exact_form)
    else:
        k = pow_ser.degree()
        M = matrix_coeff_differentials_pos(k-_sage_const_2 )
        V = vector_coeff(pow_ser.coefficients()[-_sage_const_1 ])
        X = M.solve_right(V)
        exact_form += X.dot_product(vector([x**_sage_const_0 *z**(k-_sage_const_2 ),x**_sage_const_1 *z**(k-_sage_const_2 ),x**_sage_const_2 *z**(k-_sage_const_2 )]))
        return reduction_z_pos(pow_ser-X.dot_product(vector([differential_zn(f,_sage_const_0 ,k-_sage_const_2 ),differential_zn(f,_sage_const_1 ,k-_sage_const_2 ),differential_zn(f,_sage_const_2 ,k-_sage_const_2 )])),exact_form) 

def reduction_z_neg(pow_ser,exact_form=_sage_const_0 ):
    if pow_ser.exponents()[_sage_const_0 ]>-_sage_const_1 :
        return (pow_ser,exact_form)
    else:
        k = pow_ser.exponents()[_sage_const_0 ]
        M = matrix_coeff_differentials_neg(k)
        V = vector_coeff(pow_ser.coefficients()[_sage_const_0 ])
        X = M.solve_right(V)
        exact_form += X.dot_product(vector([x**_sage_const_0 *z**(k-_sage_const_2 ),x**_sage_const_1 *z**k,x**_sage_const_2 *z**k]))
        return reduction_z_neg(pow_ser-X.dot_product(vector([differential_zn(f,_sage_const_0 ,k-_sage_const_2 ),differential_zn(f,_sage_const_1 ,k),differential_zn(f,_sage_const_2 ,k)])),exact_form)



def reduction_z(pow_ser):
    red_pow_ser_pos, exact_pos = reduction_z_pos(pow_ser)
    red_pow_ser_neg, exact_neg = reduction_z_neg(red_pow_ser_pos,exact_pos)

    exact_form = exact_neg + red_pow_ser_neg[_sage_const_1 ][_sage_const_2 ]/(differential_zn(f,_sage_const_0 ,-_sage_const_1 )[_sage_const_1 ][_sage_const_2 ])*z**(-_sage_const_1 )
    red_pow_ser_fin = red_pow_ser_neg -red_pow_ser_neg[_sage_const_1 ][_sage_const_2 ]/(differential_zn(f,_sage_const_0 ,-_sage_const_1 )[_sage_const_1 ][_sage_const_2 ])*differential_zn(f,_sage_const_0 ,-_sage_const_1 )

    return (red_pow_ser_fin,exact_form)
  

def matrix_frobenius(p,frob_omega,frob_eta,prec=_sage_const_10 , exact_dif = False):

    Z5 = Zp(p, prec, type = 'capped-abs', print_mode = 'series')
    
    red_frob_eta = reduction_coeff(frob_eta)
    red_frob_omega = reduction_coeff(frob_omega)

    red_frob_eta_fin, exact_form_eta= reduction_z(red_frob_eta)
    red_frob_omega_fin, exact_form_omega= reduction_z(red_frob_omega)

    matrix_frobenius = matrix(Z5,_sage_const_2 )
    matrix_frobenius[_sage_const_0 ,_sage_const_0 ] = red_frob_omega_fin[_sage_const_1 ][_sage_const_0 ]
    matrix_frobenius[_sage_const_0 ,_sage_const_1 ] = red_frob_omega_fin[_sage_const_1 ][_sage_const_1 ]
    matrix_frobenius[_sage_const_1 ,_sage_const_0 ] = red_frob_eta_fin[_sage_const_1 ][_sage_const_0 ]
    matrix_frobenius[_sage_const_1 ,_sage_const_1 ] = red_frob_eta_fin[_sage_const_1 ][_sage_const_1 ]

    if exact_dif:
        return (matrix_frobenius, [exact_form_omega,exact_form_eta])
    else:
        return matrix_frobenius
    
print(matrix_frobenius(p,frob_omega,frob_eta))

