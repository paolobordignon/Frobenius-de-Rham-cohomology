

# This file was *autogenerated* from the file gaussmanin.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3)
from sage.all import *

def extended_euclidean_poly(f, g):
    R = f.parent()
    x = R.gens()[_sage_const_0 ]  
    r0, r1 = f, g
    A0, A1, A2 = R(_sage_const_1 ), R(_sage_const_0 ), R(_sage_const_0 )
    B0, B1, B2 = R(_sage_const_0 ), R(_sage_const_1 ), R(_sage_const_0 )
    
    while r1.degree() != _sage_const_0 :
        r2 = r0 % r1
        q = (r0-r2)/r1
        r0 = r1
        r1 = r2
    
        A2 = A0 - q*A1
        B2 = B0 - q*B1
        
        A0 = A1
        A1 = A2
        B0 = B1
        B1 = B2
        
    return (A2/r1,B2/r1)

def GaussManin(f, exact_bool = False):
    
    S = f.parent()
    x = S.gens()[_sage_const_0 ]  
    t = S.base_ring().gens()[_sage_const_0 ]

    f_x = f.derivative(x)
    f_t = f.derivative(t)
    
    (A,B) = extended_euclidean_poly(f, f_x)

    A_t = A.derivative(t)
    B_x = B.derivative(x)
    B_t = B.derivative(t)

    domega = -_sage_const_1 /_sage_const_2 *A*f_t - A_t*f + B_x*f_t-B_t*f_x
    dxomega = x*domega + B*f_t
    domega = domega.numerator()
    dxomega = dxomega.numerator()

    deg_domega = _sage_const_0  if domega == _sage_const_0  else domega.degree()
    deg_dxomega = max(dxomega.degree(),_sage_const_0 )
    deg_max = max(deg_domega,deg_dxomega)
    
    vec_domega = [_sage_const_0 ] if domega == _sage_const_0  else domega.coefficients(sparse = False)
    vec_domega.reverse()
    vec_domega = vector(vec_domega)
    vec_dxomega = dxomega.coefficients(sparse = False)
    vec_dxomega.reverse()
    vec_dxomega = vector(vec_dxomega)

    vec_f = f.list()
    vec_f.reverse()
    vec_f_x = f_x.list()
    vec_f_x.reverse()
    
    vec_coefx = zero_vector(S,deg_max+_sage_const_1 )
    vec_coefx[deg_max-_sage_const_1 ] = _sage_const_1 
    vec_coef0 = zero_vector(S,deg_max+_sage_const_1 )
    vec_coef0[deg_max] = _sage_const_1 

    exact_form = _sage_const_0  #this exact form needs to be multiplied to deduce the correct exact form to subtract

    for n in range(_sage_const_1 ,deg_max):
    
        M_P = matrix(S,n,n,lambda i,j: vec_f_x[_sage_const_0 ] if i==j else vec_f_x[_sage_const_1 ] if i==j+_sage_const_1  else vec_f_x[_sage_const_2 ] if i==j+_sage_const_2  else _sage_const_0  )
    
        M_Px = matrix(S,n,n,lambda i,j: (n-i-_sage_const_1 )*vec_f[_sage_const_0 ] if i==j else (n-i)*vec_f[_sage_const_1 ] if i==j+_sage_const_1  else (n-i+_sage_const_1 )*vec_f[_sage_const_2 ] if i==j+_sage_const_2  else (n-i+_sage_const_2 )*vec_f[_sage_const_3 ] if i==j+_sage_const_3  else _sage_const_0  )
        
        M = _sage_const_1 /_sage_const_2 *M_P+M_Px
    
        unit_vec_xn = zero_vector(S,n)
        unit_vec_xn[_sage_const_0 ] = _sage_const_1 
    
        F = sum([b*x**a for a,b in enumerate(reversed(M**(-_sage_const_1 )*unit_vec_xn))])
        exact_form += F
        
        xn_as_exact_form = _sage_const_1 /_sage_const_2 *F*f_x+F.derivative(x)*f
        # xn_as_exact_form =  X^(n+1)+coeff_x*X+coeff_0
        
        list_coeff_x = xn_as_exact_form.numerator().list()
        list_coeff_x.reverse()
        coeff_x = list_coeff_x[n]
        vec_coefx[deg_max-n-_sage_const_1 ] = -_sage_const_1 *coeff_x
    
        list_coeff_0 = xn_as_exact_form.numerator().list()
        list_coeff_0.reverse()
        coeff_0 = list_coeff_x[n+_sage_const_1 ]
        vec_coef0[deg_max-n-_sage_const_1 ] = -_sage_const_1 *coeff_0

    xomega_coeff_domega = vec_coefx[(deg_max-deg_domega):deg_max+_sage_const_1 ].dot_product(vec_domega)
    omega_coeff_domega= vec_coef0[(deg_max-deg_domega):deg_max+_sage_const_1 ].dot_product(vec_domega)
    
    xomega_coeff_dxomega= vec_coefx.dot_product(vec_dxomega)
    omega_coeff_dxomega= vec_coef0.dot_product(vec_dxomega)
    
    GMmatrix = matrix([[omega_coeff_domega,xomega_coeff_domega],[omega_coeff_dxomega,xomega_coeff_dxomega]])

    if exact_bool:
        return (GMmatrix,exact_form)
    else:
        return GMmatrix

